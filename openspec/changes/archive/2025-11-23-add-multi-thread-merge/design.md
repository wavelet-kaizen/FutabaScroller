# Design: 複数スレッドマージ機能

## Context
現在のFutabaScrollerは単一スレッド内のレスポンスのみを扱うが、ユーザーは複数スレッドにまたがる実況ログを連続して再生したい。外部スレッドの取得、DOM統合、入力UI変更を伴うため、設計判断を記録する。

## Goals / Non-Goals

### Goals
- 複数スレッドのレスポンスをスレッド順でDOM統合し、シームレスにスクロール再生
- 開始位置を日時またはNo.で柔軟に指定可能にする
- ユーザビリティの高い入力UIとローディング表示を提供
- 既存の単一スレッド再生を壊さない

### Non-Goals
- タイムスタンプ順のレスソート（スレッド単位で追加する）
- 新しいタブでの自動スレッド切り替え（ブラウザ自動化は複雑すぎる）
- リアルタイム更新中のスレッド追加（初回マージのみ）

## Decisions

### 1. スレッドマージ方式: fetch + DOM挿入
**決定**: 外部スレッドをfetchで取得し、DOMParserでパースして現在のタブのDOM末尾に挿入する。マージ対象は `No.` をキーに昇順ソートし、既存DOM上に同一 `No.` がある場合は再挿入しない。4つのログ形式（ふたば本家、ふたクロ、tsumanne.net、Futafuta）を自動判定して対応する。

**理由**:
- ブックマークレットは既存ページのコンテキストで実行されるため、fetchが使える
- DOMに実際に挿入することで、`captureResponses()` 関数を使ってマージ済みレスポンスを取得できる
  - **注意**: Futafuta形式のスレ主投稿に対応するため、`captureResponses()` はログ形式判定を行い、Futafutaの場合は `.thre` 直下の要素も認識する必要がある
- スクロール処理も既存のscrollResponseIntoView()で動作する
- Futabaの `No.` は単調増加の一意キーなので信頼できるソート・重複判定に使える
- 各アーカイブサービスのDOM構造は異なるが、タイムスタンプとNo.のクラス名（`.cnw`, `.cno`）は共通

**代替案**:
- 仮想的なレスポンス配列を保持してスクロールをシミュレート → DOM依存のscroll処理が使えず複雑化
- iframeで別スレッドを表示 → スクロールの同期が困難

### 2. 入力UI: HTML オーバーレイフォーム
**決定**: オーバーレイでフォームを表示し、以下を入力可能にする:
- 開始位置（レス番号/日時/No. の3つから選択）
- 速度倍率
- 追加スレッドURL（複数行テキストエリア）

**理由**:
- prompt関数では複数パラメータの入力が煩雑
- ラジオボタンで入力形式を選択可能
- 既存の StatusOverlay/SpeedOverlay と同様のUIパターン

**代替案**:
- 複数回のprompt呼び出し → UX悪い、キャンセル処理が複雑
- 設定ファイルやlocalStorage → ブックマークレットでは扱いづらい

### 3. 開始位置指定の拡張
**決定**: `ThreadSettings` に `startMode` と `startValue` を追加:
```typescript
interface ThreadSettings {
    startMode: 'index' | 'timestamp' | 'no';
    startValue: number | string; // index: number, timestamp/no: string
    speedMultiplier: number;
    additionalThreadUrls: string[];
}
```

**理由**:
- レス番号は複数スレッドで重複するため、一意なNo.または絶対時刻が必要
- ユーザーが既に知っている形式（ふたばのタイムスタンプ、No.）をそのまま使える
- 既存のindex指定も維持して後方互換性を保つ
- 時刻形式は 2桁年+曜日付き (`YY/MM/DD(曜)HH:MM:SS`) に加え4桁年+曜日なし (`YYYY/MM/DD HH:MM:SS`) を許容し、曜日チェックは行わない
- No. は `.cno` テキスト (`No.1373514170` 形式) から抽出する

### 4. ローディング表示: シンプルなオーバーレイ
**決定**: LoadingOverlay クラスを作成し、"スレッド取得中..." のテキストと回転アニメーションを表示。

**理由**:
- fetch処理は数秒かかる可能性があるため、ユーザーに状態を伝える必要がある
- 既存のオーバーレイパターンと一貫性を保つ
- プログレスバーは不要（取得完了の見積もりが困難）

### 5. 起動時の一時停止
**決定**: マージ処理完了後、`Controler`（再実行時も含む）は一旦停止状態で初期化し、StatusOverlayに「準備完了、xキーで開始」と表示する。ポーリングはマージ中に停止し、マージ完了後に再開する。

**理由**:
- 外部スレッド取得中にスクロールが開始されると、追加されたレスが反映されない
- ユーザーが明示的に開始タイミングを制御できる
- 既存の一時停止機能（xキー）をそのまま利用
- 再実行時にも速度/一時停止/ポーリング状態をリセットしておくと挙動が一貫する

## Risks / Trade-offs

### リスク1: CORS制約
- **リスク**: ふたばサーバーがCORSヘッダーを返さない場合、fetchが失敗する
- **緩和策**: 失敗したURLを明示し、全体処理を中断してユーザーに通知（部分スキップはしない）
- **代替案**: fetch proxyを経由する（実装コスト高、外部依存追加）

### リスク2: DOM構造の変化
- **リスク**: ふたばのHTML構造が変わると、DOMパースや挿入が失敗する可能性
- **緩和策**: セレクタを openspec/project.md に明記し、変更時の影響範囲を明確化
- **テスト**: 手動でDOMパース結果を検証

### トレードオフ1: UI複雑化
- **トレードオフ**: HTMLフォーム追加により、コードサイズが増加（~100-150行）
- **判断**: UXの向上がコスト増を上回る（ユーザーの手動操作削減）

### トレードオフ2: 起動時の一時停止
- **トレードオフ**: 即座にスクロール開始しないため、既存ユーザーは1ステップ増える
- **判断**: StatusOverlayで明確に指示すれば、混乱は最小限

## Migration Plan
破壊的変更なし。既存の使い方（追加URLなし、レス番号指定）も引き続き動作する。

1. HTMLフォームでレス番号のみ入力 → 既存と同じ挙動
2. 追加URLを入力 → 新機能が動作
3. xキーでスクロール開始 → 新しいステップだが、オーバーレイで案内

### 6. ログ形式の自動判定
**決定**: 以下の優先順位でログ形式を判定する:
1. **Futafuta**: `<title>` 要素のテキストに `Futafuta` を含む場合
2. **tsumanne.net**: `<script src>` に `tsumanne.net` を含む、または `.cnw` に `ID:` が含まれる場合
3. **ふたクロ**: `.thre > div > table` セレクタで要素が見つかる場合
4. **ふたば本家**: 上記に該当しない場合（デフォルト）

**理由**:
- Futafuta はタイトルに必ず `|Futafuta` を含むため、これが最も堅牢な判定方法
- スクリプトURLでの判定（`backblazeb2.com/file/staticftb2bucket/`）は、スクリプト配置が変更されると動作しなくなるリスクが高い
- タイトルはサイト運営上の識別子として機能するため、変更される可能性が低い
- 優先順位を明確にすることで、複数の条件に該当する場合の挙動を一貫させる
- 各形式の抽出ロジックを個別に実装することで、将来的な形式追加にも対応しやすい

**Futafuta の特徴**:
- タイトル: `<title>...|過去ログ|Futafuta</title>` の形式
- コンテナ: `<div class="thre" data-res="...">`
- スレ主投稿: `.thre` 直下に複数の生DOM要素として配置（テキストノード、`<a>`、`<img>`、`<span class="cnw">`、`<span class="cno">`、`<blockquote>`、`<font>` など）
  - 最初の `<table border="0">` より前の全ての直下要素がスレ主投稿
  - 単一のtable要素ではないため、複数要素をグループとして扱う必要がある
- 返信レス: `<table border="0">` として配置
- タイムスタンプ/No.: `.cnw` / `.cno` クラス（ふたば本家と同じ）
- タイムスタンプ形式: `YY/MM/DD(曜)HH:MM:SS`（ふたば本家と同じ）

### 7. Futafutaのスレ主投稿の抽出とマージ
**決定**: Futafutaのスレ主投稿は、`.thre` 直下の複数要素をグループとして扱う。`<table>` より前に限らず、`.cnw` と `.cno` を含む非table連続ノード群をスレ主として検出する。

**抽出方法**:
1. `.thre` の子ノード（`childNodes`）を順番に走査
2. `<table>` 以外の連続ノード群の中で `.cnw` と `.cno` を両方含むグループをスレ主投稿として収集（テキストノード、要素ノードを含む）
3. グループの終端は次に出現する `<table>` 手前（またはDOM末尾）までとし、DOM途中に複数あっても全て検出
4. 収集したノード群から `.cnw` と `.cno` を探してタイムスタンプとNo.を抽出

**マージ方法**:
1. 全スレッドのレスポンス（スレ主投稿 + 返信レス）を No. 昇順でソート
2. スレ主投稿の場合: 収集した複数ノード（テキストノード、要素ノードを含む）を順番に `.thre` コンテナに挿入（既存 `<table>` の後ろに挿入されるケースも許容）
3. 返信レスの場合: `<table>` 要素をそのまま挿入

**理由**:
- Futafutaのスレ主投稿は単一のtable要素に包まれておらず、複数の生DOMノード（テキストノード、要素ノード）として散在している
- 追加マージ時はスレ主ノード群が `<table>` の後ろに挿入される場合があるため、最初の `<table>` だけを境界にすると後続スレ主を見逃す
- テキストノード（例: "画像ファイル名："、"-(51291 B)"）を含めて収集することで、元のDOM構造を完全に保持できる
- `childNodes` を使用することで、`children` では失われるテキストノードも保持される
- 他のログ形式（table要素単位）と統一的に扱える（レスポンス = 単一または複数のDOMノードグループ）

**代替案**:
- スレ主投稿全体を wrapper (`<div>`) で囲んで単一要素化 → DOM構造が変わるため採用しない

### 8. captureResponses() の混在形式対応
**決定**: `captureResponses()` 関数を拡張し、ベースページの形式に関係なく、DOM内の全てのログ形式（ふたば本家、ふたクロ、tsumanne.net、Futafuta）のレスポンスを認識できるようにする。

**実装方針**:
1. `.thre` コンテナの全ての子ノード（`childNodes`）を順番に走査
2. 各ノード/ノードグループを以下のルールで判定:
   - **Futafutaスレ主投稿**: `.thre` 直下で、`.cnw` と `.cno` を両方含む `<table>` 以外の連続ノードグループ（テキストノード含む）。グループ終端は次の `<table>` 手前（またはDOM末尾）
   - **table形式レス**: `<table>` 要素（ふたば本家、ふたクロ、tsumanne.net、Futafuta返信レスすべて）
3. 各ノード/グループから `.cnw` と `.cno` を探してタイムスタンプとNo.を抽出
4. 全てのレスポンスを統合して配列を生成

**理由**:
- ベースページのタイトル（`document.title`）だけでは、マージされた他形式のスレッドを認識できない
  - 例: ふたば本家ページにFutafutaスレッドをマージした場合、タイトルは「ふたば」のまま
  - タイトルで分岐すると、マージされたFutafutaのスレ主投稿（table外）は完全にスキップされる
- DOM構造ベースの判定により、混在形式でも各レスポンスを正しく認識できる
- 現在のセレクタ（`body > div.thre table .cnw`）は table 内のみを対象とするため、Futafutaスレ主投稿を見逃す
- `childNodes` の順次走査により、マージ順序を保ちつつ全形式を統一的に処理できる

**代替案**:
- マージ時に `data-format="futafuta"` 属性を付与 → DOM改変が必要で、元の構造が変わる

**影響範囲**:
- `src/dom/capture.ts`: `captureResponses()` 関数を拡張
- `tests/dom/capture.test.ts`: 混在形式のテストを追加

### 9. 開始位置解決のタイミングとエラーハンドリング
**決定**: 開始位置（レス番号/日時/No.）の解決は、スレッドマージおよびレスソート完了後に実施する。解決が失敗した場合は、入力フォームに戻して再入力させる。

**タイミング**:
1. **フォーム時点**: 形式バリデーションのみ実施（値が正の整数か、空でないか、URL形式か）
2. **マージ・ソート後**: `resolveStartPosition()` を呼び出して開始位置を解決
   - レス番号指定: マージ・ソート後の最終的な配列インデックスで範囲チェック
   - No.指定: マージ・ソート後のDOM内で存在確認
   - 日時指定: パース可能性を検証（該当レスが存在しない場合でもパースした日時から再生開始）

**エラーハンドリング**:
- `resolveStartPosition()` の戻り値: `Result<Date, StartPositionError>` 型（既存のプロジェクト共通型 `src/types.ts` で定義）
- 成功時: `{ success: true, value: Date }`
- 失敗時: `{ success: false, error: StartPositionError }`
  - `StartPositionError` の構造:
    ```typescript
    type StartPositionError =
      | { type: 'index_out_of_range'; message: string; validRange: { min: number; max: number } }
      | { type: 'no_not_found'; message: string; searchedNo: string }
      | { type: 'timestamp_parse_error'; message: string; inputValue: string }
    ```
- 失敗時の挙動:
  1. ローディングオーバーレイを非表示
  2. 入力フォームを再表示し、直前の入力内容（開始位置形式、開始位置値、速度倍率、追加スレッドURL）を全て復元
  3. 開始位置値の入力欄にエラーメッセージを表示（`error.message`）
  4. 他の入力項目は編集可能だが、デフォルト値は直前の入力内容とする

**日時指定の特別扱い**:
- 日時指定で該当レスが存在しない場合、エラーではなく正常系として扱う
- パースした日時を開始時刻として返す（`{ success: true, value: parsedDate }`）
- **スレッド開始前の日時を指定した場合**:
  - その時刻から再生を開始し、最初にその日時以降のレス（スレッドの最初のレス）が表示されるまで待機する
- **スレッド終了後の日時を指定した場合**:
  - スクロール処理は開始時（または x キー押下時）に、スレッドの最後のレスへ即座にスクロールする
  - タイムラインは終了状態として扱い、それ以上のスクロールは発生しない
  - StatusOverlay に「タイムライン終了」等のメッセージを表示する（オプション、UX向上のため）
  - 無限待機を防ぎ、ユーザーに明確なフィードバックを提供する

**理由**:
- レス番号指定時、マージ・ソートによりレス順序が変わる可能性がある（時系列的に前のスレッドを追加した場合など）
- 範囲チェックや存在確認は、最終的なDOM状態に基づいて行うべき
- フォームに戻すことで、ユーザーは修正箇所（開始位置値）だけを変更でき、追加スレッドURLや速度設定はそのまま保持される
- `Result<T, E>` 型を使用することで、既存のプロジェクト共通型との整合性を保つ

**代替案**:
- ステータスオーバーレイで通知して終了 → 再試行が困難、入力内容が失われる
- マージ前に開始位置を解決 → ソート後の状態と矛盾する可能性がある

## Open Questions
なし（ユーザーとの質問で明確化済み）
